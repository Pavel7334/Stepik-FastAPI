from fastapi import APIRouter


router = APIRouter(
    prefix="/tasks",
    tags=["Chapter_6:"]
)

#                                                     6.1

#                                             Важность обработки ошибок

# Обработка ошибок является важнейшим аспектом создания надежных веб-приложений. Это включает в себя предвидение
# потенциальных ошибок или исключений, которые могут возникнуть во время выполнения приложения, и корректную обработку
# их. В этом уроке мы сосредоточимся на пользовательской (кастомной) обработке ошибок в FastAPI, чтобы обеспечить
# информативные и удобные для пользователя ответы на ошибки.

#                                         Ответы на ошибки по умолчанию в FastAPI

# FastAPI автоматически генерирует ответы об ошибках для распространенных кодов состояния HTTP, таких как 404
# (Not found) или 500 (internal server error). Хотя эти ответы по умолчанию полезны, пользовательская обработка ошибок
# позволяет нам адаптировать ответы на ошибки в соответствии с требованиями нашего приложения.

#                                       Создание пользовательских классов исключений

# В FastAPI мы можем создавать пользовательские классы исключений, которые наследуются от встроенного класса
# `HttpException`. Эти пользовательские классы исключений позволяют нам определять конкретные сообщения об ошибках,
# коды состояния и дополнительные сведения для включения в ответ на ошибку.
#
# from fastapi import FastAPI, HTTPException
#
# app = FastAPI()
#
#
# # класс кастомного исключения для ошибок
# class CustomException(HTTPException):
#     def __init__(self, detail: str, status_code: int = 400):
#         super().__init__(status_code=status_code, detail=detail)
#
#
# # пример маршрута, который райзит (выбрасывает) кастомное исключение
# @app.get("/items/{item_id}/")
# async def read_item(item_id: int):
#     if item_id == 42:
#         raise CustomException(detail="Item not found", status_code=404)
#     return {"item_id": item_id}
# В приведенном выше примере мы создали пользовательский класс исключений `CustomException`, который наследуется от
# `HttpException`. Класс `CustomException` принимает два параметра: `detail` (сообщение об ошибке) и `status_code`
# (код состояния HTTP). Мы вызываем метод `__init__` родительского класса `HttpException` с предоставленными
# аргументами `detail` и `status_code`.
#
# В маршруте `read_item` мы проверяем, равен ли `item_id` 42. Если это так, мы создаем наше пользовательское
# исключение с сообщением об ошибке "Элемент не найден" и кодом состояния 404 (Not found). В противном случае мы
# возвращаем словарь с `item_id`.
#
# Использование пользовательских классов исключений, подобных этому, позволяет вам создавать более значимые и
# конкретные ответы на ошибки для вашего API. Вы можете адаптировать сообщения об ошибках и коды состояния в
# соответствии с требованиями вашего приложения и предоставлять клиентам четкую информацию при возникновении ошибки.

#                                 Регистрация пользовательских обработчиков исключений

# После создания пользовательских классов исключений мы можем зарегистрировать обработчики исключений для захвата и
# обработки определенных типов исключений. FastAPI предоставляет декоратор `@app.exception_handler` для связывания
# классов исключений с их соответствующими обработчиками.
#
# Давайте расширим предыдущий код для регистрации Error handler'а (обработчика исключений):
#
# from fastapi import FastAPI, HTTPException, Request
# from fastapi.responses import JSONResponse
#
# app = FastAPI()
#
#
# # не изменяли
# class CustomException(HTTPException):
#     def __init__(self, detail: str, status_code: int = 400):
#         super().__init__(status_code=status_code, detail=detail)
#
#
# # Обработчик ошибок (error handler) для класса CustomException
# @app.exception_handler(CustomException)
# async def custom_exception_handler(request: Request, exc: CustomException):
#     return JSONResponse(
#         status_code=exc.status_code,
#         content={"error": exc.detail}
#     )
#
#
# # не изменяли
# @app.get("/items/{item_id}/")
# async def read_item(item_id: int):
#     if item_id == 42:
#         raise CustomException(detail="Item not found", status_code=404)
#     return {"item_id": item_id}
# В обновленном коде мы добавили пользовательский обработчик ошибок с именем `custom_exception_handler` для класса
# `CustomException`, используя декоратор `app.exception_handler()`. Эта функция принимает два параметра: `request`
# (текущий объект запроса) и `exc` (экземпляр вызванного исключения).
#
# Функция `custom_exception_handler` возвращает `JsonResponse` с соответствующим кодом состояния HTTP и телом JSON,
# содержащим поле `error` с сообщением `detail` пользовательского исключения.
#
# Теперь всякий раз, когда в приложении возникает `CustomException` (как мы делаем в маршруте `/items/{item_id}/`),
# будет вызван пользовательский обработчик ошибок, и пользовательский ответ об ошибке будет возвращен клиенту.
#
# Такой подход позволяет вам обрабатывать конкретные исключения с помощью настраиваемых ответов, обеспечивая лучший
# контроль и согласованность при обработке ошибок во всем вашем приложении FastAPI.

#                                               Логгирование ошибок

# Логгирование ошибок - важная практика при разработке приложений. FastAPI позволяет нам регистрировать ошибки и
# соответствующую информацию, чтобы помочь в отладке и устранении неполадок. Для этих целей обычно используется
# библиотека logging. Продвинутые инструменты для работы с логами будут предложены позднее в курсе, чтобы вы знали
# об их наличии и изучили, при необходимости.

#                                       Отправка пользовательских сообщений об ошибках

# С помощью пользовательских обработчиков исключений мы можем настроить ответы на ошибки, возвращаемые нашим
# приложением FastAPI. Это позволяет нам предоставлять пользователям значимые сообщения об ошибках и полезную
# информацию при возникновении проблем. В коде в приведённом примере мы это и сделали. Вы можете настроить
# возвращаемых ответ в соответствии с вашими потребностями.

#                                           Глобальные обработчики исключений

# В дополнение к регистрации обработчиков исключений для конкретных исключений, FastAPI также позволяет нам определять
# глобальные обработчики исключений, которые перехватывают все необработанные исключения. Эти глобальные обработчики
# могут обеспечить резервный ответ на непредвиденные ошибки, чтобы предотвратить утечку конфиденциальной информации
# пользователям.
#
# Давайте добавим глобальный обработчик исключений:
#
# from fastapi import FastAPI, HTTPException, Request
# from fastapi.responses import JSONResponse
#
# app = FastAPI()
#
#
# # не изменяли
# class CustomException(HTTPException):
#     def __init__(self, detail: str, status_code: int = 400):
#         super().__init__(status_code=status_code, detail=detail)
#
#
# # не изменяли
# @app.exception_handler(CustomException)
# async def custom_exception_handler(request: Request, exc: CustomException):
#     return JSONResponse(
#         status_code=exc.status_code,
#         content={"error": exc.detail}
#     )
#
#
# # Обработчик глобальных исключений, который "ловит" все необработанные исключения
# @app.exception_handler(Exception)
# async def global_exception_handler(request: Request, exc: Exception):
#     return JSONResponse(
#         status_code=500,
#         content={"error": "Internal server error"}
#     )
#
#
# # добавили непредусмотренное исключение
# @app.get("/items/{item_id}/")
# async def read_item(item_id: int):
#     # симулируем непредусмотренное исключение
#     result = 1 / 0
#     return {"item_id": item_id}
# В приведенном выше коде у нас есть два обработчика исключений. Первый, `custom_exception_handler`, специфичен для
# класса `CustomException`, как показано в предыдущем примере.
#
# Второй обработчик исключений, `global_exception_handler`, не указывает какой-либо конкретный тип исключения, что
# делает его глобальным обработчиком исключений. Этот обработчик будет перехватывать все необработанные исключения в
# приложении FastAPI.
#
# В маршруте `/items/{item_id}/` мы имитируем необработанное исключение, разделив `1` на `0`. Поскольку это явно не
# перехватывается каким-либо конкретным обработчиком исключений, оно будет перехвачено глобальным обработчиком
# исключений.
#
# Глобальный обработчик исключений возвращает общий ответ об ошибке с кодом состояния `500` (внутренняя ошибка сервера)
# и сообщением, указывающим на то, что произошла внутренняя ошибка сервера. Это предотвращает утечку конфиденциальной
# информации к пользователям в случае непредвиденных ошибок.
#
# Определив глобальный обработчик исключений, вы можете корректно обрабатывать неожиданные исключения и предоставлять
# согласованные ответы на ошибки во всем вашем приложении FastAPI.


#                                            Модели реагирования на ошибки

# FastAPI позволяет нам определять модели реагирования на ошибки, используя модели Pydantic. Определяя структуру
# ответов об ошибках, мы можем обеспечить согласованное форматирование и данные в наших сообщениях об ошибках.
#
# Тут пример будет достаточно лаконичным:
#
# from pydantic import BaseModel
#
# # Pydantic модель ответов на ошибки
# class ErrorResponse(BaseModel):
#     error_code: int
#     error_message: str
#     error_details: str = None
# В данном примере мы наследовались от стандартного Pydantic класса BaseModel, определив, что наш кастомной класс
# будет содержать 3 поля: код ошибки, сообщение и детали. Вы можете настроить его любым необходимым образом, например
# добавив категорирование, тип или любую другую релевантную информацию.

#                                                        ЗАДАЧА

# Для этой задачи программирования вам необходимо реализовать пользовательскую обработку ошибок в приложении FastAPI.
# Ваше приложение должно включать пользовательские классы исключений, обработчики исключений и модели реагирования на
# ошибки.
#
# Требования:
#
# 1. Создайте приложение FastAPI и настройте пользовательские классы исключений по крайней мере для двух конкретных
# исключений (например, `CustomExceptionA` и `CustomExceptionB`). Каждое пользовательское исключение должно иметь
# уникальный код состояния и пользовательское сообщение об ошибке.
#
# 2. Зарегистрируйте пользовательские обработчики исключений для двух пользовательских исключений. Обработчики
# сключений должны возвращать ответы об ошибках с соответствующими кодами состояния и сообщениями об ошибках.
#
# 3. Определите модели реагирования на ошибки, используя модели Pydantic, чтобы обеспечить согласованное
# форматирование ответов на ошибки во всем приложении.
#
# 4. Реализуйте по крайней мере две конечные точки API, которые вызывают пользовательские исключения в определенных
# сценариях. Например, одна конечная точка может вызвать `CustomExceptionA`, когда не выполняется определенное
# условие, а другая конечная точка может вызвать `CustomExceptionB`, когда ресурс не найден.
#
# 5. Протестируйте свою пользовательскую обработку ошибок, отправив запросы к конечным точкам API, которые вызывают
# пользовательские исключения. Убедитесь, что ответы об ошибках содержат правильные коды состояния и сообщения об
# ошибках.
#
# Примечание: Для этой задачи вы можете использовать простые инструкции печати для регистрации ошибок. В реальном
# сценарии вы обычно использовали бы библиотеку ведения журнала для эффективной обработки регистрации ошибок.

# Модель:
#
# class ErrorResponse(BaseModel):
#     status_code: int
#     detail: str
#
#
# Все остальное:
#
# class CustomExceptionA(HTTPException):
#     def __init__(self, detail: str, status_code: int = 500):
#         super().__init__(detail=detail, status_code=status_code)
#
#
# class CustomExceptionB(HTTPException):
#     def __init__(self, detail: str, status_code: int = 400):
#         super().__init__(detail=detail, status_code=status_code)
#
#
# @app.exception_handler(CustomExceptionA)
# async def custom_exception_handler_a(request: Request, exc: ErrorResponse):
#     return JSONResponse(
#         status_code=exc.status_code,
#         content={"message": exc.detail}
#     )
#
#
# @app.exception_handler(CustomExceptionB)
# async def custom_exception_handler_b(request: Request, exc: ErrorResponse):
#     return JSONResponse(
#         status_code=exc.status_code,
#         content={"message": exc.detail}
#     )
#
#
# @app.get("/items/{item_id}")
# async def read_item(item_id: int):
#     if item_id == 5:
#         raise CustomExceptionA(detail="Server very error", status_code=500)
#     return {"item_id": item_id}
#
#
# @app.get("/primer/{primer_id}")
# async def read_item(primer_id: int):
#     if primer_id == 7:
#         raise CustomExceptionB(detail="Not found", status_code=404)
#     return {"primer_id": primer_id}

