from fastapi import APIRouter


router = APIRouter(
    prefix="/tasks",
    tags=["Chapter_8:"]
)

#                                                       8.1

#                                     Понимание внедрения зависимостей в FastAPI

# Внедрение зависимостей - это шаблон проектирования, используемый в FastAPI для управления и предоставления
# зависимостей компонентам вашего приложения. С помощью внедрения зависимостей вы можете разделить различные
# части вашего приложения, сделав его более модульным и простым в обслуживании. Встроенная система внедрения
# зависимостей FastAPI позволяет вам внедрять зависимости в функции маршрутизации и обработчики запросов.
#
# Это очень удобно, когда вам нужно:
#
# Иметь общую логику (одна и та же логика кода снова и снова).
# Совместное использование подключений к базе данных.
# Обеспечение безопасности, аутентификации, требований к ролям и т. д.
# В FastAPI класс `Depends` используется для объявления и использования зависимостей. Используя `Depends`, вы
# можете указать требования к зависимостям для маршрута или обработчика запросов. FastAPI автоматически разрешает и
# предоставляет необходимые зависимости во время обработки запроса.

#                                     Зависимости маршрутов и области их применения

# FastAPI позволяет вам определять зависимости для конкретного маршрута с помощью класса `Depends`. Вы можете указать
# различные области зависимостей, чтобы управлять сроком службы экземпляров зависимостей.
#
# Теоретический пример для демонстрации возможности. Предположим, у нас есть приложение FastAPI, которое использует
# поддельную базу данных для хранения и извлечения пользовательской информации. Мы будем использовать внедрение
# зависимостей, чтобы внедрить зависимость базы данных в функции маршрута.
#
# from fastapi import FastAPI, Depends
#
# app = FastAPI()
#
# # фейковая БД для хранения пользовательских данных
# fake_database = {
#     1: {"id": 1, "name": "John Doe"},
#     2: {"id": 2, "name": "Jane Smith"},
# }
#
# # Функция зависимости для получения экземпляра базы
# def get_database():
#     return fake_database
#
# # Функция маршрутизации с внедрением зависимостей (dependency injection)
# @app.get("/users/{user_id}")
# def get_user(user_id: int, database: dict = Depends(get_database)):
#     if user_id in database:
#         return database[user_id]
#     else:
#         return {"message": "User not found"}
#
# # Другая функция маршрутизации с тем же внедрением зависимостей
# @app.get("/users/")
# def get_all_users(database: dict = Depends(get_database)):
#     return list(database.values())
# В этом примере мы определяем поддельную базу данных `fake_database` для хранения пользовательской информации. Мы
# также создаем функцию зависимости `get_database`, которая возвращает экземпляр базы данных (`fake_database`).
#
# В обеих функциях маршрутизации `get_user` и `get_all_users` мы используем `Depends(get_database)`, чтобы внедрить
# `fake_database` в функции в качестве зависимости. Функция `Depends` сообщает FastAPI вызвать `get_database()` и
# передать возвращаемое значение в качестве аргумента функции каждого роута.
#
# Когда мы отправляем запрос GET в `/users/{user_id}` или `/users/`, FastAPI автоматически вводит (добавляет)
# `fake_database` в соответствующие функции маршрута, позволяя нам получить доступ к пользовательской информации из
# базы данных в наших обработчиках. И в дополнение - мы соблюли принцип DRY - don't repeat yourself, переиспользовав
# свою зависимость, что сделало код более читаемым и удобным.

#                                                     Middleware

# Мидлвэр в FastAPI - это такая прослойка для каждого запроса (ответа). Другими словами это функция, которая работает
# с каждым запросом до того, как он будет обработан какой-либо конкретной операцией path. А также с каждым ответом,
# прежде чем возвращать его.
#
# Порядок работы Middleware'а такой:
#
# Он принимает каждый запрос , который приходит к вашему приложению.
# Затем он может что-то сделать с этим запросом или запустить любой необходимый код.
# Затем он передает запрос на обработку остальной части приложения (некоторой Path операции).
# Затем он принимает ответ, сгенерированный приложением (некоторой операцией пути).
# Он может что-то сделать с этим ответом или запустить любой необходимый код.
# Затем он возвращает ответ .
# Примеров применения может быть множество. Вот некоторые из них: блэк лист для айпи-адресов, вайт-лист, введение
# "паузы" для загрузки, проверка "доверенных" заголовков, редирект (например на https/wss) и др.
#
# Например, можно сделать мидлвэр, который делает вид, что сервер долго грузится при частых обращениях с одного и
# того же айпишника. Пожалуй главная цель такого ПО - снижение нагрузки на сервер. Либо на этом "промежуточном" слое
# можно делать что-то, что является общим для всех запросов (например, проверка или добавление заголовков), чтобы не
# прописывать такую логику в каждой функции.
#
# Middleware создаётся в FastAPI довольно просто - с использованием декоратора `@app.middleware("http")`.
#
# Вот пример Мидлвэра, который вы можете запустить у себя и увидеть логику его работы:
#
# from fastapi import FastAPI, Request
#
# app = FastAPI()
#
# @app.middleware("http")
# async def my_middleware(request: Request, call_next):
#     print('Мидлвэр начал работу')
#     response = await call_next(request)
#     print('Мидлвэр получил обратно управление')
#     return response
#
# @app.get("/")
# def index():
#     print('привет из основного обработчика пути')
#     return {"message": "Hello, world!"}
# Давайте для примера разберём пример из официальной документации:
#
# import time
#
# from fastapi import FastAPI, Request
#
# app = FastAPI()
#
#
# @app.middleware("http")
# async def add_process_time_header(request: Request, call_next):
#     start_time = time.time()
#     response = await call_next(request)
#     process_time = time.time() - start_time
#     response.headers["X-Process-Time"] = str(process_time)
#     return response
# Мы создали Мидлвэр с помощью декоратора.
#
# Потом определили логику его работы (в качестве аргументов указали функцию, которая принимает сам объект запроса
# Request и функцию call_next).
#
# Call_next - это функция, которая передает управление дальше соответствующему обработчику пути (обработчик в примере
# не указан, но предполагается, что есть какой-то).
#
# Потом засекли текущее время. Сказали, что ответом будет то, что вернёт функция call_next (соответствующий обработчик
# пути). И сказали, что время обработки - это разница между временем текущим и тем, когда мы передали управление в
# другой обработчик.
#
# И потом мы добавляем к каждому ответу кастомный заголовок - время обработки запроса.

#                                    Усовершенствованные методы маршрутизации

# FastAPI предоставляет различные расширенные методы маршрутизации для настройки поведения конечной точки и обработки
# сложных шаблонов запросов.
#
# Настройка путей маршрута: Вы можете настроить пути маршрута, используя переменные, регулярные выражения и параметры
# запроса, для создания динамических и гибких конечных точек.
# Обработка HTTP-методов: FastAPI позволяет вам определять несколько HTTP-методов (GET, POST, PUT, DELETE и т.д.) для
# одного маршрута, что позволяет создавать более универсальные API.
# Включение и исключение маршрутов: Вы можете выборочно включать или не включать маршруты в приложение, используя
# include. Это позволяет лучше контролировать открытые конечные точки API.

#                                       Вспомогательные приложения и маршрутизаторы API

# FastAPI поддерживает вспомогательные вложенные приложения (суб-приложения) и маршрутизаторы API, которые позволяют
# вам организовывать свой код в более мелкие, повторно используемые компоненты. Вспомогательные приложения или
# маршрутизаторы могут быть подключены к основному приложению, что позволяет лучше организовать код и разделить задачи.
#
# Давайте посмотрим на примерах о чем речь.
#
# Суб-приложения
# Например у вас была первая версия вашего API, но потом вы его сильно поменяли. Но хотите сохранить поддержку
# предыдущего. В FastAPI это сделать очень просто.
#
# Допустим у вас есть файл api_v1.py (или другое суб-приложение):
#
# from fastapi import FastAPI
#
# # создаём суб-приложение
# api_v1_app = FastAPI()
#
# # определяем роут в суб-приложении
# @api_v1_app.get("/sub/")
# def read_sub():
#     return {"message": "This is a sub-application route."}
# Потом посмотрим на основной файл вашего FastAPI, допустим main.py:
#
# from fastapi import FastAPI
# from api_v1 import api_v1_app
#
# # создаём главное FastAPI приложение
# app = FastAPI()
#
# # монтируем суб-приложение в основное приложение
# app.mount("/v1", api_v1_app)
#
# # создаём обычный роут в главном приложении
# @app.get("/")
# def root():
#     return {"message": "Hello from main app"}
# Каждое подобное субприложение FastAPI будет иметь свою документацию, работать независимо от других приложений и
# будет обрабатывать свои запросы, зависящие от пути. В данном случае у нас будет доступен основной роут
# http://localhost:8000/ и роут суб-приложения http://localhost:8000/v1/sub/. Как видим, для доступа к роутам
# суб-приложений используется префикс (у нас /v1/).
#
# Маршрутизаторы API
# Когда маршрутов становится слишком много, то ими становится неудобно управлять. Маршруты могут дублироваться или
# перекрывать друг друга.
#
# FastAPI имеет собственную систему API-маршрутизации. API-роуты (APIRouters) можно рассматривать как мини-приложения
# FastAPI, которые являются зависимой частью более крупного приложения (без основного приложения они не могут
# существовать).
#
# Давайте посмотрим как FastAPI может помочь.
#
# Например есть 3 файла:
#
# Файл 1 - electronics.py:
#
# from fastapi import APIRouter
#
# electronicsroute = APIRouter()
#
# @electronicsroute.get('/info')
# def electronics():
#     return {"detail": "This electronics info is from the electronics APIRouter",
#             "name": "Electronics XYZ",
#             "brand": "ABC Electronics"}
# Файл 2 - gadgets.py:
#
# from fastapi import APIRouter
#
# gadgetsroute = APIRouter()
#
# @gadgetsroute.get('/info')
# def gadgets():
#     return {"detail": "This gadgets info is from the gadgets APIRouter",
#             "name": "Cool Gadget",
#             "manufacturer": "Gadget Co."}
# Как видите, в обоих файлах есть маршрут /info.
#
# Чтобы их было возможно обрабатывать, давайте соединим их в третьем main.py файле:
#
# from fastapi import FastAPI
# from electronics import electronicsroute
# from gadgets import gadgetsroute
#
#
# app = FastAPI()
# app.include_router(electronicsroute, prefix="/electronics")
# app.include_router(gadgetsroute, prefix="/gadgets")
#
# @app.get('/')
# def index():
#     return "Welcome to the Electronics Store"
# Вы могли заметить, что мы создавали не инстанс приложения FastAPI, как в случае с суб-приложениями, а
# использовали класс APIRouter.
#
# В файле main.py мы включили оба роутера и установили префикс для каждого.
#
# Теперь есть возможность обратиться как к основным роутам главного приложения (http://localhost:8000/), так и к
# каждому из роутов /info, используя соответствующий префикс: http://localhost:8000/electronics/info и
# http://localhost:8000/gadgets/info.
#
# Таким образом, может быть несколько API-роутов для обработки параметров, в зависимости от того, какой тип операции
# нужно выполнить для разных групп эндпоинтов.

#                                            Вложенные объекты для тела запроса

# FastAPI предоставляет более широкие возможности при проверке данных запроса при помощи Pydantic моделей.
#
# Рассмотрим пример:
#
# from fastapi import FastAPI
# from pydantic import BaseModel
#
# app = FastAPI()
#
#
# class Image(BaseModel):
#     url: str
#     name: str
#
#
# class Item(BaseModel):
#     name: str
#     description: str | None = None
#     price: float
#     tax: float | None = None
#     tags: set[str] = set()
#     image: Image | None = None
#
#
# @app.put("/items/{item_id}")
# async def update_item(item_id: int, item: Item):
#     results = {"item_id": item_id, "item": item}
#     return results
# Тут мы сначала объявили модель `Image`, и далее в объекте `Item` её вложили. После этого передали эту модель в
# соответствующую функцию, обрабатывающую PUT-запрос. Соответственно FastAPI будет ожидать такой входящий JSON:
#
# {
#     "name": "Foo",
#     "description": "The pretender",
#     "price": 42.0,
#     "tax": 3.2,
#     "tags": ["rock", "metal", "bar"],
#     "image": {
#         "url": "http://example.com/baz.jpg",
#         "name": "The Foo live"
#     }
# }
# Таким образом FastAPI позволяет настраивать валидируемые схемы данных любым удобным для нас способом, что повышает
# общую гибкость приложения.
#
# Напомним, что FastAPI автоматически генерирует UI-документацию для вашего кода благодаря поддержке Swagger
# (через него также можно делать тестирование вашего API). Её можно посмотреть по адресам:

#                                                    8.2

#                                      Понимание веб-сокетов в веб-приложениях

# WebSockets предоставляют двунаправленный канал связи между клиентом и сервером по единственному долговременному
# соединению. В отличие от традиционных HTTP-запросов, когда клиент отправляет запрос и ожидает ответа, WebSockets
# обеспечивают асинхронную связь в режиме реального времени. Это делает их идеальными для приложений, требующих
# постоянного обновления данных, приложений для чата, игр в реальном времени и инструментов совместной работы.

#                                           Поддержка WebSocket в FastAPI

# FastAPI имеет встроенную поддержку для обработки подключений WebSocket, что упрощает интеграцию функций реального
# времени в ваши приложения. С помощью класса `WebSocket`, предоставляемого FastAPI, вы можете создавать маршруты
# WebSocket и обрабатывать события WebSocket, такие как подключение, отключение и получение сообщений.

#                                              Создание маршрутов WebSocket

# В FastAPI вы можете определить маршруты WebSocket, используя декоратор `@app.websocket`. Маршруты WebSocket
# отделены от обычных HTTP-маршрутов и позволяют вам обрабатывать соединения WebSocket и события с помощью
# асинхронных функций.

#                                               Обработка событий WebSocket

# Маршруты WebSocket в FastAPI могут обрабатывать различные события (созданные функции):
#
# `on_connect`: это событие запускается, когда клиент подключается к маршруту WebSocket (например, `websocket.accept()`) .
#
# `on_disconnect`: это событие запускается, когда клиент отключается от маршрута WebSocket (например, `websocket.close()`).
#
# `on_message`: это событие запускается, когда сервер получает сообщение от клиента (например, `websocket.recieve_text()` или `websocket.send_text()`).

#                                                  Двунаправленная связь

# Как только соединение с WebSocket установлено, и клиент, и сервер могут отправлять сообщения друг другу асинхронно.
# Это обеспечивает обмен данными и обновления в режиме реального времени, обеспечивая бесперебойный пользовательский
# интерфейс для приложений реального времени.

#                                               Безопасность веб-сокета

# FastAPI поддерживает аутентификацию WebSocket, позволяя вам защищать маршруты WebSocket и ограничивать доступ
# только для прошедших проверку подлинности пользователей. Вы можете использовать те же механизмы аутентификации,
# которые используются в обычных HTTP-маршрутах, такие как OAuth2 или JWT.

#                                   Приложения реального времени с FastAPI и WebSockets

# Поддержка WebSocket в FastAPI делает его отличным выбором для создания приложений реального времени и интерактивных
# функций. Вы можете создавать приложения для чата, системы уведомлений в режиме реального времени, инструменты для
# совместного редактирования и многое другое с помощью WebSockets и высокопроизводительных возможностей FastAPI.

#                           Пример простого FastAPI приложения с использованием Websocket'ов

# from fastapi import FastAPI, WebSocket, WebSocketDisconnect
#
# app = FastAPI()
#
# # список для хранения подключённых WebSocket клиентов
# connected_clients = []
#
#
# # WebSocket-роут для обработки WebSocket подключений
# @app.websocket("/ws/")
# async def websocket_endpoint(websocket: WebSocket):
#     await websocket.accept()
#     connected_clients.append(websocket)
#
#     try:
#         while True:
#             data = await websocket.receive_text()
#             await websocket.send_text(f"Message text was: {data}")
#     except WebSocketDisconnect:
#         connected_clients.remove(websocket)
#
#
# # роут для массовой рассылки сообщений всем подключённым клиентам
# @app.get("/broadcast/")
# async def broadcast_message(message: str):
#     for client in connected_clients:
#         await client.send_text(f"Broadcast message: {message}")
#
# Как видно из кода, у нас есть отдельный веб-сокет роут (/ws/), который мы сделали с использованием соответствующего
# декоратора. Наша асинхронная конечная точка (websocket_endpoint) будет удерживать соединение.
#
# В этой точке мы сначала принимаем (акцептируем) вебсокет-соединение. Далее добавляем клиента в список подключённых.
# Потом в бесконечном цикле мы "слушаем" соединения (ждём получения текста). Если получили, то отправили это сообщение
# обратно, чуть изменив. Если клиент отключается, то мы его удаляем из нашего списка и цикл прерывается.
#
# Дополнительно мы создали обычный роут для получения сообщений. Если сообщение получим, то разошлем его всем
# вебсокет-клиентам из списка.

#                                                     8.3

#                                       Введение в варианты развертывания

# После разработки приложения FastAPI следующим шагом является его развертывание, чтобы сделать его доступным для
# пользователей. Развертывание включает в себя обеспечение доступности приложения на сервере или облачной платформе,
# гарантируя, что оно сможет эффективно обрабатывать входящие запросы и доставлять ответы. FastAPI предоставляет
# различные варианты развертывания в соответствии с различными вариантами использования и требованиями.

#                                       Развертывание с помощью ASGI-серверов

# ASGI (Asynchronous Server Gateway Interface) - это интерфейс между веб-серверами и веб-приложениями на Python.
# FastAPI построен на ASGI и может быть развернут с использованием ASGI-серверов, таких как Uvicorn, Hypercorn или
# Daphne. Серверы ASGI предназначены для эффективной работы с асинхронными веб-фреймворками, такими как FastAPI, что
# делает их предпочтительным выбором для производственных развертываний.
#
# Давайте посмотрим на них чуть подробнее:
#
# 1. Uvicorn - это легкий ASGI-сервер, специально разработанный для быстрых ASGI-фреймворков, таких как FastAPI и
# Starlette. Он основан на библиотеке uvloop, которая представляет собой сверхбыструю реализацию цикла обработки
# событий. Uvicorn обеспечивает хорошую производительность и подходит для приложений с высокой степенью параллелизма.
# Он совместим с библиотекой asyncio.
#
# 2. Hypercorn также является ASGI-сервером, но разработан как более универсальный и готовый к работе с различными
# программами. Он нацелен на совместимость с широким спектром ASGI-фреймворков и построен поверх библиотеки asyncio.
# Hypercorn поддерживает HTTP / 1, HTTP / 2 и WebSockets, что делает его универсальным выбором для различных
# приложений. Стоит отметить, что гиперкорн помимо asyncio поддерживает Trio (более новая библиотека асинхронности,
# которая по словам разработчиков попроще, чем asyncio).
#
# 3. Daphne - это еще один сервер ASGI, и он специально разработан для приложений Django. Он разработан для
# обслуживания ASGI-совместимых приложений Django и предоставляет производственный интерфейс для запуска Django
# Channels и обработки подключений WebSocket.
#
# Таким образом, Uvicorn ориентирован на скорость и производительность, Hypercorn стремится стать более гибким и
# готовым к работе ASGI-сервером, а Daphne оптимизирован для запуска приложений Django с поддержкой ASGI.
#
# По-умолчанию рекомендуем Uvicorn, если вы не находитесь на продвинутом уровне, так как FastAPI под него "заточен".
# Наилучший выбор среди этих серверов зависит от конкретных требований и фреймворков, используемых в вашем
# веб-приложений.
#
# Теоретически можно развернуть приложение только при помощи uvicorn'a, но тогда будет несколько минусов, таких как
# отсутствие https и то, что будет всего один процесс. Этот вариант подходит только для неопытных. Для этого можно
# указать на каком хосте и порту он будет работать. Чтобы он мониторил все айпи машины, его запускают с
# командой --host 0.0.0.0.

#                                              Развертывание с помощью Docker

# Docker - популярная платформа, используемая для упаковки приложений и их зависимостей в контейнеры. С помощью Docker
# вы можете создать контейнер для своего приложения FastAPI, гарантируя его согласованную работу в различных средах.
# Контейнеры Docker являются легкими, портативными и обеспечивают надежный способ развертывания приложений FastAPI в
# средах разработки, промежуточных или производственных средах.
#
# Тем более, что для бэкэнд-разработчика во многих вакансиях требуется знание/понимание Docker (реже встретите
# необходимость знакомства с Kubernetes, т.к. там уже есть отдельно DevOps'ы наверняка).
#
# Пример бесплатного курса по Docker на степике:
#
# https://stepik.org/course/123300
#
# Еще пример бесплатного курса по Docker:
#
# https://karpov.courses/docker
#
#
#
# Так как потребности в архитектуре бэкенда у всех разные, то мы не можем дать универсальный рецепт для всех.
# Мануалов имеется достаточно, и это довольно интересный опыт вывода в продакшн.
#
# Но если бы стоял вопрос о том, как сделать это максимально просто самому (с хорошим потенциалом масштабирования),
# то можно было бы посоветовать использовать официальный докер-образ связки uvicorn-gunicorn-fastapi, который можно
# найти по ссылке (там же можно прочитать про запуск):
#
# https://github.com/tiangolo/uvicorn-gunicorn-fastapi-docker
#
# Для старта соответственно можете для сначала поставить только эту связку гуникорн-ювикорн-фастапи (гуникорн на
# порту 80 передаёт всё единственному ювикорну, а тот работает с фастапи). Потом делаете несколько процессов увикорна,
# а гуникорн перенаправляет запросы им. А потом уже усложняет дальше.
#
# Например, в реальных проектах, можно сделать такую связку: докер-образ Nginx'а выступает в роли фронт-сервера на
# портах :80 (http), :443 (https) (балансировщика*, который распределяет нагрузку по другим бэк-серверам; для https
# ему нужен будет Certbot). Далее идёт Gunicorn (wsgi-сервер), который выступает в роли менеджера процессов (пидов)
# uvicorn'а. Uvicorn уже взаимодействуют напрямую с FastAPI. Все это крутится в виде докер-образов.
#
# Мануал по такой связке (на английском языке, но без Docker'а):
#
# https://dylancastillo.co/fastapi-nginx-gunicorn/
#
# Эта инструкция подойдёт, если у вас есть свой/арендованный выделенный/виртуальный сервер. Мы бы могли
# порекомендовать RuVDS, там можно взять себе для тестов VPS за символические 40 рублей в
# месяц (https://ruvds.com/cheap_vps/).
#
# За FastAPI уже стоят Redis/Memcached (для кэша) + Postgres SQL (для хранения данных).
#
# *подробнее про балансировку через Nginx:
#
# https://habr.com/ru/companies/first/articles/683870/

#                                         Развертывание на облачных платформах

# Приложения FastAPI могут быть развернуты на различных облачных платформах, включая AWS, Google Cloud,
# Microsoft Azure, Яндекс и Heroku. Облачные платформы предлагают масштабируемую инфраструктуру, балансировку
# нагрузки, автоматическое масштабирование и различные другие функции для обеспечения высокой доступности и
# производительности. В целом деплой в облаках ещё проще самостоятельного развертывания докер-образов, но есть
# несколько оговорок:
#
# 1) это может стоить дороже;
#
# 2) будете зависеть от политики платформ (например риск отказа в оказании услуг, тк вы можете быть из России);
#
# 3) случись авария у сервиса, мы не сможем повлиять на ускорение восстановления работоспособности.
#
# Поэтому рекомендуется взвесить все за и против любого из предложенных вариантов.
#
# Вариантом бесплатного (на первое время) облачного сервиса можем предложить Digital Ocean, которые при регистрации
# дают пробные 200$ (хватить должно где-то на пол года).

#                                              Мониторинг и ведение журнала

# Развернутые приложения FastAPI следует отслеживать и регистрировать в журнале, чтобы отслеживать производительность,
# выявлять проблемы и обеспечивать бесперебойную работу. Инструменты мониторинга, такие как Prometheus и Grafana,
# могут быть интегрированы в приложения FastAPI для сбора и визуализации показателей производительности. Правильное
# ведение журнала гарантирует, что ошибки и важные события будут записаны, что облегчает диагностику и устранение
# неполадок.

#                               Непрерывная интеграция и непрерывное развертывание (CI/CD)

# CI/CD - это практика разработки, которая включает автоматизацию процесса интеграции изменений кода в основную
# кодовую базу и развертывания приложений в рабочей среде. Конвейеры CI/CD настроены для автоматической сборки,
# тестирования и развертывания приложений FastAPI всякий раз, когда в хранилище кода вносятся изменения. Такая
# практика гарантирует быстрое и надежное развертывание новых функций и исправлений ошибок.

#                                            Нагрузочное тестирование

# Перед развертыванием приложения FastAPI в рабочей среде следует провести нагрузочное тестирование, чтобы оценить
# его производительность при различных нагрузках. Инструменты нагрузочного тестирования, такие как Locust или JMeter,
# можно использовать для моделирования большого числа одновременных пользователей и оценки времени отклика приложения
# и масштабируемости.
